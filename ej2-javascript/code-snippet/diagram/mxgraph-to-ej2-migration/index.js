const { Diagram } = ej.diagrams;

const mxGraphXMLData = `
<mxGraphModel dx="933" dy="555" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1040" pageHeight="300" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="lXHuHNEkXH5VenCzG6mj-22" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="lXHuHNEkXH5VenCzG6mj-5" target="lXHuHNEkXH5VenCzG6mj-6" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="170" y="160" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-23" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="lXHuHNEkXH5VenCzG6mj-6" target="lXHuHNEkXH5VenCzG6mj-7" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-24" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="lXHuHNEkXH5VenCzG6mj-7" target="lXHuHNEkXH5VenCzG6mj-8" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-16" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;strokeWidth=2;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" source="lXHuHNEkXH5VenCzG6mj-8" target="lXHuHNEkXH5VenCzG6mj-9" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-17" value="YES" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="lXHuHNEkXH5VenCzG6mj-16" vertex="1" connectable="0">
          <mxGeometry relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-18" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fillColor=#f8cecc;strokeColor=#b85450;strokeWidth=2;" parent="1" source="lXHuHNEkXH5VenCzG6mj-8" target="lXHuHNEkXH5VenCzG6mj-11" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-19" value="NO" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="lXHuHNEkXH5VenCzG6mj-18" vertex="1" connectable="0">
          <mxGeometry relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-25" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" parent="1" source="lXHuHNEkXH5VenCzG6mj-9" target="lXHuHNEkXH5VenCzG6mj-10" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-26" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" parent="1" source="lXHuHNEkXH5VenCzG6mj-11" target="lXHuHNEkXH5VenCzG6mj-12" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-5" value="Order Received" style="ellipse;html=1;aspect=fixed;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=top;fontStyle=1;strokeWidth=2;shadow=0;" parent="1" vertex="1">
          <mxGeometry x="60" y="130" width="40" height="40" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-6" value="Retrieve Data" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;fontStyle=0;strokeWidth=2;" parent="1" vertex="1">
          <mxGeometry x="180" y="120" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-7" value="Approve Data" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;fontStyle=0;strokeWidth=2;" parent="1" vertex="1">
          <mxGeometry x="380" y="120" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-8" value="Approved?" style="rhombus;whiteSpace=wrap;html=1;fontStyle=0;labelPosition=center;verticalLabelPosition=middle;align=center;verticalAlign=middle;strokeWidth=2;" parent="1" vertex="1">
          <mxGeometry x="580" y="120" width="80" height="60" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-9" value="Order Items" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;fontStyle=0;strokeWidth=2;" parent="1" vertex="1">
          <mxGeometry x="740" y="60" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-10" value="Order Processed" style="ellipse;html=1;aspect=fixed;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=top;strokeWidth=4;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="940" y="70" width="40" height="40" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-11" value="Send Rejection Mail" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#f8cecc;strokeColor=#b85450;fontStyle=0;strokeWidth=2;" parent="1" vertex="1">
          <mxGeometry x="740" y="180" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="lXHuHNEkXH5VenCzG6mj-12" value="Order Not Processed" style="ellipse;html=1;aspect=fixed;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=top;strokeWidth=4;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="940" y="190" width="40" height="40" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
`;

// This function loads XML data, parses it into EJ2 Diagram elements, and renders the diagram.
try {
  const xmlDocument = new window.DOMParser().parseFromString(
    mxGraphXMLData,
    'application/xml'
  );
  const { nodes, connectors } = parseMxGraph(xmlDocument);

  const diagram = new Diagram({
    width: '100%',
    height: '600px',
    nodes,
    connectors,
    snapSettings: { constraints: ej.diagrams.SnapConstraints.All },
  });

  diagram.appendTo('#element');
  diagram.dataBind();
  diagram.refresh();
} catch (error) {
  console.error(error);
}

// Parses mxGraph XML to extract nodes and connectors to be converted into EJ2 Diagram format
function parseMxGraph(xmlDoc) {
  const mxCells = Array.from(xmlDoc.querySelectorAll('mxCell'));
  const nodes = [];
  let connectors = [];
  const nodeMap = {};
  const childMap = {};
  const containerNodes = [];
  const groupDefs = [];

  // Iterate over mxCells to categorize them into nodes and connectors
  mxCells.forEach((cell) => {
    const style = cell.getAttribute('style') || '';
    const styles = parseStyleString(style);
    const isVertex = cell.getAttribute('vertex') === '1';
    const isEdge = cell.getAttribute('edge') === '1';
    let isLabel = cell.getAttribute('connectable') === '0';
    const isGroup = style.includes('group');
    const id = cell.getAttribute('id');
    const parent = cell.getAttribute('parent');

    // Group shapes are treated as vertices, not labels
    if (isGroup) isLabel = false;

    // Convert mxGraph vertex cells (excluding labels) to EJ2 nodes
    if (isVertex && !isLabel) {
      const isContainer =
        'containerType' in styles || style.includes('swimlane');
      const node = createNode(cell, styles);
      nodeMap[id] = node;

      if (parent) {
        childMap[parent] = childMap[parent] || [];
        childMap[parent].push(id);
      }

      if (isContainer) {
        containerNodes.push({ id, node });
      } else if (isGroup) {
        groupDefs.push({ id, node });
      } else {
        nodes.push(node);
      }
    } else if (isEdge) {
      // Convert mxGraph edge cells to EJ2 connectors
      connectors.push(createConnector(cell, styles, mxCells));
    }
  });

  // Associate children nodes with their parent containers or groups
  attachChildrenToParents(childMap, nodeMap);

  // Finalize the list of nodes and connectors for the EJ2 diagram
  finalizeNodesAndConnectors(
    nodes,
    connectors,
    containerNodes,
    groupDefs,
    childMap
  );

  return { nodes, connectors };
}

// Parses a style string into an object for easier manipulation while creating EJ2 elements
function parseStyleString(str) {
  const out = {};
  str.split(';').forEach((token) => {
    if (!token) return;
    const [k, v] = token.split('=');
    if (v === undefined) out.shape = k;
    else out[k] = v;
  });
  return out;
}

// Creates EJ2 diagram nodes from mxGraph cells based on style and geometric data
function createNode(cell, s) {
  const geo = cell.querySelector('mxGeometry');
  const x = +geo.getAttribute('x') || 0;
  const y = +geo.getAttribute('y') || 0;
  const w = +geo.getAttribute('width') || 100;
  const h = +geo.getAttribute('height') || 100;

  const shape = resolveShape(s);
  const node = configureNodeBase(cell, w, h, x, y, shape, s);

  const annotationStyle = parseFontStyle(s.fontStyle);
  const rawContent = decodeAnnotationContent(cell, s);
  const annotation = configureAnnotation(s, shape, rawContent, annotationStyle);
  node.annotations.push(annotation);

  if (shape.shape === 'Decision') {
    addDecisionPorts(node);
  }

  return node;
}

// Configures node base properties from geometric and style data
function configureNodeBase(cell, width, height, offsetX, offsetY, shape, s) {
  return {
    id: cell.getAttribute('id'),
    width,
    height,
    offsetX: offsetX + width / 2,
    offsetY: offsetY + height / 2,
    shape,
    style: {
      fill: s.fillColor || '#ffffff',
      strokeColor: s.strokeColor || '#000000',
      strokeWidth: +(s.strokeWidth || 1),
    },
    annotations: [],
  };
}

// Decodes HTML entity encoded content from mxGraph XML
function decodeAnnotationContent(cell, s) {
  const isHtml = s.html === '1';
  const rawContent = isHtml
    ? decodeHtmlEntities(cell.getAttribute('value') || '')
    : cell.getAttribute('value') || '';
  return rawContent;
}

// Resolves the appropriate shape for EJ2 from mxGraph styling
function resolveShape(s) {
  const shapeLookup = {
    ellipse: { type: 'Basic', shape: 'Ellipse' },
    rhombus: { type: 'Flow', shape: 'Decision' },
    rectangle: { type: 'Basic', shape: 'Rectangle' },
  };
  const shape = shapeLookup[s.shape] || shapeLookup.rectangle;

  if (shape.shape === 'Rectangle' && s.rounded === '1') {
    shape.cornerRadius = 8;
  }

  return shape;
}

// Configures annotation based on position and style information from mxGraph
function configureAnnotation(s, shape, rawContent, annotationStyle) {
  const annotation = {
    content: rawContent,
    style: annotationStyle,
  };

  if (shape.shape === 'Ellipse') {
    annotation.offset = { x: 0.5, y: 1 };
    annotation.margin = { top: 5 };
    annotation.verticalAlignment = 'Top';
    annotation.fontWeight = '500';
    annotation.width = 'auto';
  } else {
    annotation.verticalAlignment =
      s.verticalLabelPosition === 'bottom' ? 'Bottom' : 'Center';
  }

  return annotation;
}

// Adding ports to decision nodes to support connector bindings
function addDecisionPorts(node) {
  node.ports = [
    { id: 'portTop', offset: { x: 0.5, y: 0 } },
    { id: 'portBottom', offset: { x: 0.5, y: 1 } },
  ];
}

// Creates EJ2 diagram connectors from mxGraph edges
function createConnector(cell, s, mxCells) {
  const connector = {
    id: cell.getAttribute('id'),
    type: 'Orthogonal',
    sourceID: cell.getAttribute('source'),
    targetID: cell.getAttribute('target'),
    style: {
      strokeColor: s.strokeColor || '#000000',
      strokeWidth: +(s.strokeWidth || 1),
    },
  };

  // Attach connector labels for YES/NO conditions
  attachLabelToConnector(connector, cell, mxCells);

  return connector;
}

// Associates labels from edge children to their connectors
function attachLabelToConnector(connector, cell, mxCells) {
  const labelCell = mxCells.find(
    (c) =>
      c.getAttribute('parent') === connector.id &&
      c.getAttribute('connectable') === '0' &&
      c.hasAttribute('value')
  );

  if (labelCell) {
    const labelStyle = parseFontStyle(
      parseStyleString(labelCell.getAttribute('style')).fontStyle
    );
    const label = labelCell.getAttribute('value').toLowerCase();

    connector.annotations = [
      {
        content: labelCell.getAttribute('value'),
        style: labelStyle,
      },
    ];

    if (label === 'yes') {
      connector.sourcePortID = 'portTop';
    } else if (label === 'no') {
      connector.sourcePortID = 'portBottom';
    }
  }
}

// Map children to parents within the diagram, aiding in proper hierarchy structuring
function attachChildrenToParents(childMap, nodeMap) {
  Object.entries(childMap).forEach(([parentId, childIds]) => {
    if (nodeMap[parentId]) {
      nodeMap[parentId].children = childIds;
    }
  });
}

// Finalize and filter out containers from regular nodes and connectors for accurate rendering
function finalizeNodesAndConnectors(
  nodes,
  connectors,
  containerNodes,
  groupDefs,
  childMap
) {
  containerNodes.forEach(({ node }) => {
    nodes.push(node);
  });

  groupDefs.forEach(({ id }) => {
    const children = childMap[id] || [];
    if (children.length) {
      nodes.push({ id, children });
    }
  });

  const containerIds = new Set(containerNodes.map((c) => c.id));
  connectors = connectors.filter(
    (c) => !containerIds.has(c.sourceID) && !containerIds.has(c.targetID)
  );
}

// Interprets font style from mxGraph format for EJ2 rendering
function parseFontStyle(fontStyleValue) {
  const style = {};
  const styleCode = parseInt(fontStyleValue || '0', 10);

  if ((styleCode & 1) === 1) style.bold = true;
  if ((styleCode & 2) === 2) style.italic = true;
  if ((styleCode & 4) === 4) style.textDecoration = 'Underline';

  style.textAlign = 'Left';
  return style;
}

// Decodes HTML entities in JavaScript
function decodeHtmlEntities(text) {
  const div = document.createElement('div');
  div.innerHTML = text;
  return div.innerText || div.textContent;
}
